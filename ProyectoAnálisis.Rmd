--- 
title: "Proyecto Análisis"
output:
  html_document:
    toc: true
    toc_depth: 2
author: "Maddi Casaiz y Ana Díaz"
date: "`r Sys.Date()`"
--- 


```{r include=FALSE}
library(sf)
library(ggplot2)
library(leaflet)
library(osmdata)
library(dplyr)
library(readr)
library(lubridate)

```

Importar y preparar la base de datos para el estudio que queremos realizar

```{r}
datos <- read_csv("aemet_datos_diarios.csv")
datos$fecha <- as.Date(datos$fecha, format="%Y-%m-%d")
datos$año <- year(datos$fecha)
datos$mes <- month(datos$fecha)
estaciones <- c()

for (mes in datos$mes) {
  if (mes >= 3 && mes <= 5) {
    estaciones <- c(estaciones, 'primavera')
  } else if (mes >= 6 && mes <= 8) {
    estaciones <- c(estaciones, 'verano')
  } else if (mes >= 9 && mes <= 11) {
    estaciones <- c(estaciones, 'otoño')
  } else {
    estaciones <- c(estaciones, 'invierno')
  }
}
datos$estacion <- estaciones
datos$tmax <- as.character(datos$tmax)
datos$tmin <- as.character(datos$tmin)
datos$tmed <- as.character(datos$tmed)
datos$tmax <- parse_number(datos$tmax) / 10  
datos$tmin <- parse_number(datos$tmin) / 10
datos$tmed <- parse_number(datos$tmed) / 10

datos <- datos[!is.na(datos$tmin) & !is.na(datos$tmed) & !is.na(datos$tmax), ]
datos$fecha_num <- lubridate::decimal_date(datos$fecha)
```
###1###
#Evolución de las temperaturas a lo largo de los años 

Regresión lineal de las temperaturas desde 2000

```{r}






modelo <- lm(tmed ~ fecha_num, data = datos)
coef = coefficients(modelo)
recta1 = coef[1] + seq(2000,2025,1)* coef[2]
x <- seq(2000,2025,1)
plot(tmed ~ fecha_num, data = datos,
        ylab="Temperatura máxima (°C)",
        xlab="Año",
        main="Temperaturas diarias")

lines(x, recta1)

```

Añadamos a esta gráfica las temperaturas mínimas y la temperatura media

```{r}
modelo2  <- lm(tmin ~ fecha_num, data = datos)
coef2 = coefficients(modelo2)
recta2 = coef2[1] + seq(2000,2025,1)* coef2[2]

lines(x, recta2)

modelo3  <- lm(tmin ~ fecha_num, data = datos)
coef3 = coefficients(modelo3)
recta3 = coef3[1] + seq(2000,2025,1)* coef3[2]

lines(x, recta3)
```

###2###
#Relacion entre las medias de temperatura alta y baja

```{r}
boxplot(tmax ~ tmin, data = datos)
t.test(datos$tmax, datos$tmin, paired = True)

```
###3###
#¿El calentamiento afecta a todas las estaciones por igual?
```{r}
#test anova de las distintas estaciones
boxplot(tmed ~ estacion, data = datos)

```
###4###
#Variabilidad por estaciones de hora de temperatura máxima y mínima

En verano
```{r}
modelo  <- lm(horatmax ~ fecha_num, data = which(datos$estacion == 'verano')
coef = coefficients(modelo)
recta1 = coef[1] + seq(2000,2025,1)* coef[2]
x <- seq(2000,2025,1)
plot(horatmax ~ fecha_num, data = datos,
        ylab="Temperatura máxima (°C)",
        xlab="Año",
        main="Temperaturas diarias")
lines(x, recta1)

```
En otoño

```{r}
modelo  <- lm(horatmax ~ fecha_num, data = which(datos$estacion == 'otoño')
coef = coefficients(modelo)
recta1 = coef[1] + seq(2000,2025,1)* coef[2]
x <- seq(2000,2025,1)
plot(horatmax ~ fecha_num, data = datos,
        ylab="Temperatura máxima (°C)",
        xlab="Año",
        main="Temperaturas diarias")
lines(x, recta1)

```
En invierno
```{r}
modelo  <- lm(horatmax ~ fecha_num, data = which(datos$estacion == 'invierno')
coef = coefficients(modelo)
recta1 = coef[1] + seq(2000,2025,1)* coef[2]
x <- seq(2000,2025,1)
plot(horatmax ~ fecha_num, data = datos,
        ylab="Temperatura máxima (°C)",
        xlab="Año",
        main="Temperaturas diarias")
lines(x, recta1)

```

En primavera
```{r}
modelo  <- lm(horatmax ~ fecha_num, data = which(datos$estacion == 'oprimavera')
coef = coefficients(modelo)
recta1 = coef[1] + seq(2000,2025,1)* coef[2]
x <- seq(2000,2025,1)
plot(horatmax ~ fecha_num, data = datos,
        ylab="Temperatura máxima (°C)",
        xlab="Año",
        main="Temperaturas diarias")
lines(x, recta1)
```
Comparamos las coef[2] de cada una de ellas (la pendiente)
Veamos ahora si la diferencia de medias de horas máximas entre el primer y último año son estadísticamente significativas

```{r}
datos_ultimo = which(datos, datos$año == 2024)
datos_primero = which(datos, datos$año == 2000)
t.test(datos_primero$horatmax, datos_ultimo$horatmax)
```
###5###
#Regresión lineal múltiple para predecir la temperatura máxima diaria
```{r}
pairs(~tmax+tmin+tmed+año+mes+horatmax+horatmin+prec+velmedia+presmin+presmax+hrMedia, data=datos, pch = 16, cex = 0.5)
modelo_mult <- lm(tmax ~ tmin + tmed + año + mes + horatmax + horatmin + prec + velmedia + presmin + presmax + hrMedia, data = datos)
summary(modelo_mult)
vif(modelo_mult)
```

```{r}
pairs(~tmax+tmin+tmed+año+mes+horatmax+horatmin+prec+velmedia+presmin+presmax+hrMedia, data=datos, pch = 16, cex = 0.5)
modelo_mult <- lm(tmax ~ tmin + tmed + año + mes + horatmax + horatmin + prec + velmedia + presmin + presmax + hrMedia, data = datos)
summary(modelo_mult)
vif(modelo_mult)
```

```{r}
fit1  <- lm(tmax ~ ., data = datos)
fit2 <- lm(tmax ~ 1, data = datos)
modelAIC <- step(fit2, scope = list(lower=fit2, upper=fit1), direction="forward")
formula <- formula(modelAIC)
modelFinal <- lm(formula, data = datos)
summary(modelFinal)
vif(modelFinal)
```
#Como podemos ver por el VIF las variables están poco correlacionadas entre sí. Es decir Step AIC ha funcionado correctamente para eliminar las variables que estaban correlacionadas.

###6###

```{r}
#Preparar los datos para su uso
datos2 = read.csv("aemet_datos_diarios_pamplona.csv")
datos2$fecha <- as.Date(datos2$fecha, format="%Y-%m-%d")
datos2$año <- year(datos2$fecha)
datos2$mes <- month(datos2$fecha)
estaciones <- c()

for (mes in datos2$mes) {
  if (mes >= 3 && mes <= 5) {
    estaciones <- c(estaciones, 'primavera')
  } else if (mes >= 6 && mes <= 8) {
    estaciones <- c(estaciones, 'verano')
  } else if (mes >= 9 && mes <= 11) {
    estaciones <- c(estaciones, 'otoño')
  } else {
    estaciones <- c(estaciones, 'invierno')
  }
}
datos2$estacion <- estaciones
datos2$tmax <- as.character(datos2$tmax)
datos2$tmin <- as.character(datos2$tmin)
datos2$tmed <- as.character(datos2$tmed)
datos2$tmax <- parse_number(datos2$tmax) / 10  
datos2$tmin <- parse_number(datos2$tmin) / 10
datos2$tmed <- parse_number(datos2$tmed) / 10

datos2 <- datos2[!is.na(datos2$tmin) & !is.na(datos2$tmed) & !is.na(datos2$tmax), ]
datos2$fecha_num <- lubridate::decimal_date(datos2$fecha)
```
Realizamos todos los analisis que los apartados 1,2 y 5 para la base de datos de aemet_datos_diarios_pamplona

```{r}
#Evolucion de las temperaturas a lo largo de los años 
# Calcular medias anuales para tmax y tmin
medias_tmax <- aggregate(tmax ~ año, data = datos2, mean)
medias_tmin <- aggregate(tmin ~ año, data = datos2, mean)

# Unir a medias_anuales2
medias_anuales2 <- merge(medias_anuales2, medias_tmax, by = "año")
medias_anuales2 <- merge(medias_anuales2, medias_tmin, by = "año")

# Ahora medias_anuales2 tiene las columnas: año, tmed, tmax, tmin
# Ajustar modelos para tmax y tmin
modelo_tmed <- lm(tmed ~ año, data = medias_anuales2)
modelo_tmax <- lm(tmax ~ año, data = medias_anuales2)
modelo_tmin <- lm(tmin ~ año, data = medias_anuales2)

# Coeficientes
coef_tmed <- coefficients(modelo_tmed)
coef_tmax <- coefficients(modelo_tmax)
coef_tmin <- coefficients(modelo_tmin)

# Generar secuencia de años para las rectas
x <- seq(2000, 2025, 1)
recta_tmed <- coef_tmed[1] + x * coef_tmed[2]
recta_tmax <- coef_tmax[1] + x * coef_tmax[2]
recta_tmin <- coef_tmin[1] + x * coef_tmin[2]

# Graficar - vamos a hacer un gráfico con los puntos de tmed, tmax y tmin
plot(tmed ~ año, data = medias_anuales2, 
     ylab = "Temperatura (°C)", 
     xlab = "Año",
     main = "Temperaturas medias, máximas y mínimas anuales",
     ylim = range(medias_anuales2[, c("tmed", "tmax", "tmin")]), 
     pch = 16, col = "black")
points(tmax ~ año, data = medias_anuales2, pch = 16, col = "red")
points(tmin ~ año, data = medias_anuales2, pch = 16, col = "blue")

# Añadir las rectas de tendencia
lines(x, recta_tmed, col = "black")
lines(x, recta_tmax, col = "red")
lines(x, recta_tmin, col = "blue")

# Leyenda
legend("topleft", 
       legend = c("Media", "Máxima", "Mínima"), 
       col = c("black", "red", "blue"), 
       pch = 16, 
       lty = 1)

#¿RELACION ENTRE LAS MEDIAS DE TEMPERATURA ALTA Y BAJA?

boxplot(tmax ~ tmin, data = datos2)
t.test(datos2$tmax, datos2$tmin, paired = TRUE)

```
#APARTADO 7
#Determina por qué hay diferencias

#Base de datos combinada
# APARTADO 7: Preparación de datos combinados - SOLUCIÓN DEFINITIVA

# 1. EXCLUIR COLUMNAS PROBLEMÁTICAS Y MANTENER SOLO LAS NECESARIAS
columnas_analisis <- c(
  "fecha",      # Fecha
  "tmed",       # Temperatura media
  "prec",       # Precipitación
  "tmin",       # Temperatura mínima
  "horatmin",   # Hora temperatura mínima
  "tmax",       # Temperatura máxima
  "horatmax",   # Hora temperatura máxima
  "dir",        # Dirección del viento
  "velmedia",   # Velocidad media del viento
  "racha",      # Ráfaga máxima
  "sol",        # Horas de sol
  "presMax",    # Presión máxima
  "presMin",    # Presión mínima
  "hrMin",      # Humedad relativa mínima
  "hrMax",      # Humedad relativa máxima
  "mes",        # Mes (a extraer de fecha)
  "año"         # Año (a extraer de fecha)
)

# Verificar qué columnas existen en ambas bases
columnas_en_datos <- intersect(columnas_analisis, names(datos))
columnas_en_datos2 <- intersect(columnas_analisis, names(datos2))

# Columnas comunes que usaremos
columnas_comunes <- intersect(columnas_en_datos, columnas_en_datos2)
cat("Columnas comunes para el análisis:", columnas_comunes, "\n")

# 2. PREPARAR CADA BASE DE DATOS POR SEPARADO
# San Sebastián
datos_ss <- datos %>%
  select(all_of(columnas_comunes)) %>%
  mutate(
    fecha = as.Date(fecha),
    año = year(fecha),
    mes = month(fecha),
    tipo_ciudad = "San Sebastian"
  )

# Pamplona
datos_pam <- datos2 %>%
  select(all_of(columnas_comunes)) %>%
  mutate(
    fecha = as.Date(fecha),
    año = year(fecha), 
    mes = month(fecha),
    tipo_ciudad = "Pamplona"
  )

# 3. VERIFICAR ESTRUCTURAS ANTES DE COMBINAR
cat("Estructura de datos_ss:\n")
str(datos_ss)
cat("\nEstructura de datos_pam:\n")
str(datos_pam)

# 4. COMBINAR LAS BASES DE DATOS
datos_combinados <- bind_rows(datos_ss, datos_pam) %>%
  mutate(
    tipo_ciudad = as.factor(tipo_ciudad),
    estacion = as.factor(estacion)
  )

# 5. LIMPIEZA DE DATOS FALTANTES EN VARIABLES CLAVE
datos_combinados_clean <- datos_combinados %>%
  filter(
    !is.na(tmax) & !is.na(tmin) & !is.na(tmed),
    !is.na(tipo_ciudad)
  )

cat("Filas después de limpiar NAs:", nrow(datos_combinados_clean), "\n")

#¿Qué parámetros son significativos en una ciudad pero no en la otra?

datos$estacion <- factor(datos$estacion)
modelo_sanse <- lm(tmed ~ tmax + tmin + hrMedia + año + mes, data = datos)
coefs1 = summary(modelo_sanse)$coefficients 
coeficientes_significativos_sanse <- coefs[coefs[,4] < 0.05, ]

datos2$estacion <- factor(datos2$estacion)
modelo_pamp <- lm(tmed ~ tmax + tmin + hrMedia + año + mes, data = datos)
coefs2 = summary(modelo_pamp)$coefficients 
coeficientes_significativos_pamp <- coefs[coefs[,4] < 0.05, ]

#Cuantificar CUÁNTO importa globalmente ser costera/interior
# Modelo sin factor ciudad
modelo_sin_ciudad <- lm(tmax ~ ., data = datos_combinados %>% select(tmax, all_of(predictores)))

# Modelo con factor ciudad (sin interacciones)
modelo_con_ciudad <- lm(tmax ~ . + tipo_ciudad, data = datos_combinados %>% select(tmax, all_of(predictores), tipo_ciudad))

# Comparación de modelos
t.test(modelo_sin_ciudad, modelo_con_ciudad)

# Cálculo de varianza explicada
r2_sin <- summary(modelo_sin_ciudad)$r.squared
r2_con <- summary(modelo_con_ciudad)$r.squared
varianza_explicada <- r2_con - r2_sin

#donde y como se manifiestan esas diferencias
# Modelo con interacciones completas
modelo_interacciones <- lm(
  tmax ~ (.) * tipo_ciudad, 
  data = datos_combinados %>% select(tmax, all_of(predictores), tipo_ciudad)
)

# Resumen de interacciones significativas
summary(modelo_interacciones)

# Extraer coeficientes de interacción
coef_interacciones <- tidy(modelo_interacciones) %>%
  filter(str_detect(term, "tipo_ciudad"))

#cuantificar exactamente cuanto difieren los efectos (matriz de contrastes)

library(multcomp)

# Contrastes específicos para parámetros clave
contrastes <- matrix(c(
  # Contraste 1: ¿El efecto de la humedad es igual en ambos tipos?
  0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0,  # humedad + humedad:tipo_ciudad = 0?
  # Contraste 2: ¿El efecto del viento es igual?
  0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0   # viento + viento:tipo_ciudad = 0?
), nrow = 2, byrow = TRUE)

prueba_contrastes <- glht(modelo_interacciones, linfct = contrastes)
summary(prueba_contrastes)

